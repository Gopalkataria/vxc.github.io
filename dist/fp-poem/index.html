<!DOCTYPE html><meta charset="utf-8"><p>Expressions have Meaning.
The Meaning is Contextual.</p>
<p>Programs are Expressions,
Expressions are reducible.
In the crucible of the Interpreter,
the Meaning is deducible.</p>
<p>Syntax is superficial.
Pick one
that’s easy ‘n sensible.
While you’re at it,
it may, for good measure,
be extensible.</p>
<p>Values are what you have,
when Expressions are normalizable.
Identifiable and immutable.
Plain and irreducible,
Their existence, irrefutable.</p>
<p>Semantics is simplificational,
compositional and substitutional.
Depending on what you like,
axiomatic, operational or denotational.</p>
<p>Bindings are persistent,
and lexical.
Those recursive? Circular,
and paradoxical.</p>
<p>For, circularity and self-application,
you conclude, after  some meditation,
are at the heart of
Recursive Functions that are Nameless.
and except when baseless (or tasteless),
are begotten, you realise somewhat later
from  Y, the mysterious
Fixed Point combinator.</p>
<p>Referential transparency,
is not about efficiency.
Young Man!
‘Tis a Call to Reason!
Unlike Assignment,
which is forbidden,
and tantamount to treason!</p>
<p>Still, if Effects is what want you might,
Try this thing called Monadic.
I’m told they’re  tricky to get right,
it’s best when they are sporadic.</p>
<p>Functions are values,
applicable, and higher-order.
It’s what let’s you write
programs that are shorter.</p>
<p>Functions have Types.
Types are polymorphic.
And isomorphic,
to propositions,
that are logical.
Programs are like proofs,
of theorems  mathematical.</p>
<p>The moral of this allegory:
Lambda is a Category,
that is closed and Cartesian.
If you don’t believe me,
check with a logician,
or a type theoretician.</p>
<p>Iteration is Recursion.
Recursion in tail position.
Recursion is Iteration,
just pass the Continuation!</p>
<p>Be warned! In calling with
the current continuation,
exercise considerable caution,
lest there is confusion,
or a catastrophic situation!</p>
<p>An Object is a Closure.
(I learned this from a Hoosier.)
Formals, body and  bindings of
free variables that are mutable.
Methods are functions over Self,
in a position that’s suitable.</p>
<p>Data is algebraic, and inductive.
Processes, co-algebraic, and co-inductive.
Now, just in case,
you find  this
so charming and seductive,
there’s also reasoning
that’s abductive and deductive.</p>
<p>Logic is Magic.
Magic is Logic.
Ask Smullyan, who did both,
besides Puzzles and Music.</p>
<p>Application is Evaluation.
Abstraction is Implication.
Value the destination,
by most estimation.</p>
<p>Alpha is permutable.
Beta, Eta, the ritual.
Lambda, the Ultimate.
and Omega, the perpetual.</p>
<p>”You know its value,
but do you know its cost?”
Laments the Garbage Collector,
(the Solitary Sweeper?)
and borrows from Frost:
The lists are lovely, long and deep,
But I have promised to mark the Heap,
And bytes to go before I sweep.
And bytes to go before I sweep.</p>
<p>Ah, a whole class in verse!
Now, isn’t that perverse?
But,  what is a program,
if not a poem?
At least, this is what
I wish to show ‘em.</p>
<p>I could go on
and on,
waxing along,
right or wrong.
But now it’s time
to close this song.
A functional program
would never be so long.</p>